# 7.2 Evolution Decision Log

**Purpose:** Template and historical record for architectural decisions
**Format:** Lightweight Architecture Decision Records (ADRs)
**Last Updated:** December 6, 2025

---

## Decision Record Template

Use this template when documenting significant architectural or design decisions:

```markdown
## [YYYY-MM-DD] Decision Title

**Status:** Proposed | Accepted | Deprecated | Superseded

**Context:**
What prompted this decision? What problem are we solving?
What constraints exist?

**Decision:**
What was decided? Be specific and actionable.

**Alternatives Considered:**
What else could we have done? Why were they rejected?

**Consequences:**
- **Positive:**
  - Benefit 1
  - Benefit 2

- **Negative:**
  - Cost 1
  - Tradeoff 2

- **Neutral:**
  - Side effect 1
  - Observable change 2

**Related Decisions:**
- Links to related or dependent ADRs
- Supersedes: [ADR-XXX]
- Related to: [ADR-YYY]

**Implementation Notes:**
Files changed, key commits, migration path (if applicable)

**Validation:**
How will we know if this decision was correct?
What metrics or signals indicate success/failure?
```

---

## Historical Decisions

### [2025-11-29] Four-Layer Architecture Design

**Status:** ✅ Accepted

**Context:**
Original three-layer design (Layer 1: Knowledge Graph, Layer 2: Backend, Layer 3: SiYuan Plugin) was complete but lacked reading interface. Users needed ability to explore knowledge while reading source materials. Gap between "backend APIs exist" and "users can actually read and explore books."

**Decision:**
Add Layer 4 (Readest Integration) as dedicated reading interface with flow exploration:
- Layer 1: Knowledge Graph (Neo4j + Qdrant + Calibre)
- Layer 2: Backend Services (FastAPI APIs)
- Layer 3: SiYuan Plugin (Processing Hub/Dashboard)
- Layer 4: Readest Integration (Reading Interface)

**Alternatives Considered:**
1. **SiYuan-only interface** — Rejected: SiYuan not designed for long-form reading
2. **Custom reader from scratch** — Rejected: 200+ hours to build epub/pdf renderer
3. **Browser extension** — Rejected: Limited to web content, not local books
4. **Readest fork** — Accepted: MIT license, Tauri-based, modern stack

**Consequences:**
- **Positive:**
  - Reading + exploration in single interface
  - Entity overlay directly in source text
  - Breadcrumb capture during reading
  - Proven epub/pdf renderer (foliate-js)
  - Tauri desktop app (cross-platform)

- **Negative:**
  - Additional codebase to maintain
  - Cross-app state sync complexity
  - Learning Readest architecture
  - Potential upstream divergence

- **Neutral:**
  - Two frontend frameworks (SiYuan: Svelte, Readest: React)
  - Two deployment models (SiYuan: Docker, Readest: native)

**Related Decisions:**
- Related to: [2025-12-04] Calibre Integration (single source of truth for books)
- Related to: [2025-12-05] Cross-App Design System (unified UX)

**Implementation Notes:**
- `docs/plans/2025-12-03-integrated-reading-knowledge-system.md` — Design doc
- `.worktrees/readest/` — Worktree for integration work
- `feature/readest-integration` branch

**Validation:**
- ✅ Users can open books from Calibre library
- ✅ Entity overlay highlights concepts in text
- ✅ Click entity → Flow panel opens
- ✅ Journey breadcrumbs captured during reading

---

### [2025-12-04] Calibre as Single Source of Truth

**Status:** ✅ Accepted

**Context:**
Initial design used file hashes and titles to match books to entities. Fragile: rename file → loses connection. Multiple systems tracking books (local files, Neo4j, backend). No authoritative catalog. Books existed in different states (some indexed, some not), no tracking system.

**Decision:**
Calibre library becomes canonical source of truth:
- `calibre_id` is universal book identifier across all systems
- Backend queries Calibre `metadata.db` directly
- Books API serves from Calibre library
- Ingestion daemon processes Calibre books sequentially
- Book status tracked in Neo4j Book nodes

**Alternatives Considered:**
1. **File-based with hashing** — Rejected: Fragile, no metadata
2. **Custom book database** — Rejected: Reinventing Calibre
3. **Cloud storage (S3/GCS)** — Rejected: Adds complexity, cost
4. **Calibre API over network** — Considered but deferred: Requires calibre-server running

**Consequences:**
- **Positive:**
  - One source of truth (Calibre)
  - Rich metadata (title, author, tags, covers)
  - Proven library management
  - 179 books immediately available
  - Status tracking (pending → enriched)
  - Auto-ingestion daemon scalable

- **Negative:**
  - Hardcoded Calibre path (needs .env)
  - SQLite direct queries (schema coupling)
  - Calibre must be local (can't run backend remotely without Calibre)

- **Neutral:**
  - Docker volume mount for Calibre library
  - calibre_id in all entity relationships

**Related Decisions:**
- Related to: [2025-11-29] Four-Layer Architecture (enables Readest library browser)
- Supersedes: Hash-based book matching
- Related to: [2025-12-04] Multi-Pass Ingestion (processes Calibre books)

**Implementation Notes:**
- `ies/backend/src/ies_backend/services/calibre_service.py` — Queries metadata.db
- `ies/backend/src/ies_backend/api/books.py` — Books API
- `scripts/ingest_calibre.py` — Manual ingestion
- `scripts/auto_ingest_daemon.py` — Background processing
- Commit: `9542ec2` (Books API), `3c2efde` (Ingestion)

**Validation:**
- ✅ Books API returns 179 books from Calibre
- ✅ Entity lookup by calibre_id works
- ✅ Auto-ingestion processes books sequentially
- ✅ 10/179 books indexed with entities

**Outstanding:**
- [ ] Move Calibre path to environment variable

---

### [2025-12-05] ADHD-Friendly Dual Status System

**Status:** ✅ Accepted

**Context:**
Need to track both AI processing state and user engagement state for captured ideas. Single `status` field conflated "has AI processed this?" with "is user exploring this?" Example: AI adds metadata (processed) but user hasn't looked at it yet (not exploring). Previous systems forced choice: track processing OR engagement, not both.

**Decision:**
Implement two independent status systems:

1. **`capture_status`** (AI processing): `raw` → `classified` → `processed`
2. **`status`** (user engagement): `captured` → `exploring` → `anchored`

Allows seed to be `classified` (AI done) but still `captured` (user hasn't explored).

**Alternatives Considered:**
1. **Single status field** — Rejected: Conflates AI and user states
2. **Boolean flags** — Rejected: Doesn't capture progression
3. **Enum with combined states** — Rejected: Explosion of combinations (3×3 = 9 states)
4. **Processing tags** — Rejected: Less structured, harder to query

**Consequences:**
- **Positive:**
  - AI can process without affecting user lifecycle
  - User sees "unread" items even if AI processed
  - Clear separation of concerns
  - Enables AI background processing
  - Non-judgmental growth metaphor (captured → exploring → anchored)

- **Negative:**
  - Two fields to manage
  - UI must explain distinction
  - More complex queries (filter by both)
  - Schema migration for existing data

- **Neutral:**
  - TypeScript enums defined in `blocks.ts`
  - Backend has separate schemas

**Related Decisions:**
- Related to: [2025-12-05] IES SiYuan Architecture Merge
- Related to: ADHD-friendly ontology design (resonance, energy)

**Implementation Notes:**
- `.worktrees/siyuan/ies/plugin/src/types/blocks.ts` lines 16-19
- TypeScript types: `CaptureStatus`, `UserStatus`
- Python schemas: `ies/backend/src/ies_backend/schemas/capture.py`
- Commit: `30df4d6` (TypeScript), `4889fed` (Backend)

**Validation:**
- ✅ Seeds can be classified but not yet explored
- ✅ User status independent of processing
- ✅ Dashboard filters work on both statuses
- ✅ Growth metaphor clear in UI

---

### [2025-12-05] Nine Question Classes Over Generic Prompts

**Status:** ✅ Accepted

**Context:**
Generic AI questions feel robotic, don't guide cognition effectively. Users couldn't distinguish between types of questions. No structure for what KIND of thinking to invite. System asked questions but they all felt the same. Research on inquiry approaches (Socratic, CBT, Phenomenological) showed structure matters.

**Decision:**
Implement 9 distinct question classes mapped to cognitive functions:

1. **Schema-Probe** — Reveal hidden structure
2. **Boundary** — Clarify edges and limits
3. **Dimensional** — Introduce spectra and gradients
4. **Causal** — Explore mechanisms
5. **Counterfactual** — What-if explorations
6. **Anchor** — Ground in concrete instances
7. **Perspective-Shift** — Change viewpoint
8. **Meta-Cognitive** — Examine thinking patterns
9. **Reflective-Synthesis** — Integrate insights

Each class has distinct templates, cognitive hints, and appropriate contexts.

**Alternatives Considered:**
1. **Single question pool** — Rejected: No structure, all feel same
2. **8 inquiry approaches** — Deferred: Too complex for Phase 1, parking lot
3. **Random questions** — Rejected: No progression or coherence
4. **User-written questions** — Rejected: Defeats purpose of AI partner

**Consequences:**
- **Positive:**
  - Questions guide specific cognitive functions
  - Users can learn their thinking patterns
  - Mode transitions have clear structure
  - Templates reusable across contexts
  - Visual badges help recognition (color-coded)

- **Negative:**
  - More complex implementation
  - AI must classify appropriately
  - Users must learn 9 classes
  - Templates require maintenance

- **Neutral:**
  - Backend classifies questions
  - SiYuan displays class hints
  - Readest shows class badges

**Related Decisions:**
- Related to: [2025-12-05] Mode Transition Engine
- Related to: User cognitive profile (6 dimensions)
- Enables: Adaptive questioning based on state

**Implementation Notes:**
- `ies/backend/src/ies_backend/api/question_engine.py`
- `ies/backend/src/ies_backend/services/question_templates_service.py`
- `.worktrees/siyuan/ies/plugin/src/views/ForgeMode.svelte` (QUESTION_CLASS_HINTS)
- 50 backend tests for question classification
- Commit: `1d1ca9f`

**Validation:**
- ✅ Questions tagged with classes in API
- ✅ UI shows class-specific hints
- ✅ Users can distinguish question types
- ✅ Mode transitions use appropriate classes

**Documentation:**
- `docs/IES question engine expansion.md`
- `docs/ies-master-analysis/1-cognition/1.3-Guided-Thinking-Patterns.md`

---

### [2025-12-05] Unified Design System Across Interfaces

**Status:** ✅ Accepted (Implementation Ongoing)

**Context:**
SiYuan plugin (Svelte) and Readest integration (React) built independently with different color palettes, typography, spacing, component styles. Inconsistent user experience across interfaces. Entity type colors differed. Dark themes worked differently. No shared design language.

**Decision:**
Create "IES Design System" — unified design tokens (colors, typography, spacing, shadows, animations) as CSS custom properties compatible with both Svelte and React:

**Core Aesthetic:** "Contemplative Knowledge Space" (The Reading Room)
- **Typography:** 4-font system (Crimson Pro, Nunito, Inter, JetBrains Mono)
- **Colors:** Warm paper tones, amber accent, sage secondary
- **Entity colors:** Type-specific (Blue Concept, Green Person, Purple Theory, Orange Framework, Red Assessment)
- **Spacing:** 8px base unit, 11-step scale
- **Shadows:** 6-level elevation system

**Alternatives Considered:**
1. **Separate design systems** — Rejected: Inconsistent UX
2. **Component library** — Deferred: Too complex, shared tokens sufficient
3. **Material Design** — Rejected: Not ADHD-friendly, generic feel
4. **Tailwind classes** — Rejected: Doesn't work across Svelte/React

**Consequences:**
- **Positive:**
  - Consistent colors, spacing, typography
  - ADHD-friendly visual hierarchy
  - Shared entity type colors
  - Dark theme works uniformly
  - CSS variables work in both frameworks

- **Negative:**
  - Migration effort for existing components
  - Two stylesheets to maintain (initial + overrides)
  - Design review needed per component

- **Neutral:**
  - globals.css pattern for Readest
  - design-system.scss for SiYuan
  - Worktree for design work (`.worktrees/ux-dev/`)

**Related Decisions:**
- Related to: [2025-11-29] Four-Layer Architecture (needs unified UX)
- Related to: Entity type colors (shared across layers)

**Implementation Notes:**
- `docs/plans/UNIFIED-DESIGN-SYSTEM.md` — 801-line specification
- `.worktrees/siyuan/ies/plugin/src/styles/design-system.scss`
- `.worktrees/readest/readest/apps/readest-app/src/app/globals.css`
- `.worktrees/ux-dev/` worktree for design system work

**Validation:**
- ✅ Design system specification complete
- ✅ SiYuan plugin imports design-system.scss
- ⏳ Readest globals.css partially integrated (entity colors done)
- ⏳ All components updated to use tokens

**Outstanding:**
- [ ] Complete Readest design system integration
- [ ] Component-by-component migration
- [ ] Dark theme verification

---

### [2025-12-06] Worktree Organization for Parallel Development

**Status:** ✅ Accepted

**Context:**
Master branch contains backend + shared docs. Feature work (SiYuan, Readest, UX) needs isolation. Using `git checkout` switches entire workspace, losing context. Concurrent work on multiple features blocked by single working directory.

**Decision:**
Use git worktrees for parallel development:

- **Root (`/brain_explore/`)** — Master branch: backend, shared docs
- **`.worktrees/siyuan/`** — `feature/siyuan-evolution`: Layer 3 plugin
- **`.worktrees/readest/`** — `feature/readest-integration`: Layer 4 reader
- **`.worktrees/ux-dev/`** — `feature/ux-development`: Design system
- **`.worktrees/readest-critique/`** — `feature/readest-critique`: Pressure testing

Each worktree has its own `TASK.md` with feature-specific objectives.

**Alternatives Considered:**
1. **Single workspace with branch switching** — Rejected: Loses context, can't compare
2. **Separate repositories** — Rejected: Shared code duplication
3. **Monorepo with workspace packages** — Rejected: More complex than needed
4. **Git submodules** — Rejected: Painful workflow

**Consequences:**
- **Positive:**
  - Work on multiple features simultaneously
  - Compare implementations side-by-side
  - Isolated task tracking per worktree
  - No context switching overhead
  - Can run SiYuan + Readest simultaneously

- **Negative:**
  - Disk space (5 copies of repo)
  - Must remember `cd` to switch (not `git checkout`)
  - Shared files must merge carefully
  - Learning curve for collaborators

- **Neutral:**
  - Each worktree is ~200MB
  - TASK.md per worktree, not in master
  - Documentation notes which worktree for which work

**Related Decisions:**
- Related to: [2025-11-29] Four-Layer Architecture (enables parallel Layer 3/4 work)
- Enables: Concurrent feature development
- Enables: Pressure testing without disrupting main work

**Implementation Notes:**
- `docs/WORKTREE-GUIDE.md` — Complete reference
- Created: Nov 30 - Dec 5, 2025
- All worktrees active, tracked in STATUS-DASHBOARD.md

**Validation:**
- ✅ Worktrees enable parallel development
- ✅ No conflicts merging back to master
- ✅ Task tracking isolated per feature
- ✅ Can compare implementations easily

---

### [2025-12-06] IES Master Analysis Documentation Generation

**Status:** ✅ Accepted

**Context:**
28 comprehensive documents needed to explain IES system to AI agents and developers. Manual writing would take weeks. Implementation details scattered across 4 layers. No single source explaining complete system. New AI agents need hours to understand architecture.

**Decision:**
Generate canonical IES documentation through agent-based code analysis:

**28 documents in 7 sections:**
- **0-system:** Overview, glossary, architecture diagram
- **1-cognition:** Profile, entry points, thinking patterns
- **2-modes:** Capture, dialogue, flow specs + mode transitions
- **3-schemas:** Seed, block, notebook, entity graph schemas
- **4-architecture:** SiYuan structure, backend pipeline, APIs, MCP
- **5-visuals:** Graph visualizations, AST maps, Flow UI
- **6-audits:** Feature checklist, implementation gaps, principle verification
- **7-meta:** Roadmap, decision log (this doc), testing, AI analysis prompt

Generated via 4-phase plan with dependency ordering.

**Alternatives Considered:**
1. **Manual documentation** — Rejected: 40-60 hours, likely outdated quickly
2. **README-only approach** — Rejected: Too shallow for AI agents
3. **Code comments only** — Rejected: Doesn't explain WHY
4. **Wiki/Notion** — Rejected: Not version-controlled, not in repo

**Consequences:**
- **Positive:**
  - Canonical reference for AI agents
  - Documentation matches actual implementation
  - Dependency-ordered content
  - Searchable, version-controlled
  - Onboarding new developers faster
  - Explains WHY, not just WHAT

- **Negative:**
  - Initial generation effort (12-16 hours)
  - Must maintain as code evolves
  - Risk of docs diverging from code
  - 28 files to keep updated

- **Neutral:**
  - Markdown format
  - Lives in `docs/ies-master-analysis/`
  - Referenced by CLAUDE.md

**Related Decisions:**
- Enables: AI agent understanding
- Related to: All architectural decisions (documents them)
- Supersedes: Scattered documentation in CLAUDE.md, README files

**Implementation Notes:**
- `docs/ies-master-analysis/` — 28 documents organized in 7 folders
- `docs/plans/2025-12-05-master-analysis-agent-plan.md` — Generation plan
- `Master list.md` — Requirements spec
- Agent H generating this document

**Validation:**
- ✅ Phase 1-3 documents generated (Foundation, Core, Technical)
- ⏳ Phase 4 documents (Validation) in progress
- ⏳ This meta-documentation being generated
- [ ] New AI agent can understand system in <30 minutes

---

## Decision-Making Guidelines

### When to Create an ADR

Create an ADR for decisions that:
- ✅ Affect multiple layers/components
- ✅ Have significant consequences (positive or negative)
- ✅ Involve tradeoffs between alternatives
- ✅ Impact future development or system evolution
- ✅ Change fundamental assumptions or principles
- ✅ Introduce new dependencies or technologies

### When NOT to Create an ADR

Skip ADR for:
- ❌ Trivial implementation details
- ❌ Obvious bug fixes
- ❌ Code style or formatting
- ❌ Renaming variables/files
- ❌ Temporary workarounds (mark in code comments instead)

### ADR Status Lifecycle

1. **Proposed** — Decision under consideration, alternatives being evaluated
2. **Accepted** — Decision made and implemented
3. **Deprecated** — Decision no longer recommended but not yet replaced
4. **Superseded** — Decision replaced by newer ADR (link to successor)

### Review Cadence

- Review ADRs quarterly
- Mark outdated decisions as deprecated
- Update validation sections with actual outcomes
- Link related decisions as architecture evolves

---

## Future Decision Templates

### Performance Optimization Decision Template

```markdown
## [YYYY-MM-DD] Performance: {Optimization Title}

**Bottleneck:** What is slow? Measured how?
**Target:** Performance goal (e.g., <500ms API response)
**Solution:** What optimization chosen?
**Tradeoffs:** What complexity added?
**Validation:** Before/after metrics
```

### Integration Decision Template

```markdown
## [YYYY-MM-DD] Integration: {System A} ↔ {System B}

**Integration Point:** Where do systems connect?
**Protocol:** HTTP, MCP, WebSocket, etc.
**Data Flow:** Direction and format
**Error Handling:** What happens when connection fails?
**Testing:** How validated?
```

### Deprecation Decision Template

```markdown
## [YYYY-MM-DD] Deprecation: {Feature/Component Name}

**Reason:** Why deprecating?
**Replacement:** What replaces it?
**Migration Path:** How do users transition?
**Timeline:** When will it be removed?
**Impact:** Who/what is affected?
```

---

## References

**Related Documents:**
- `docs/five-agent-synthesis.md` — Analysis of architectural decisions
- `docs/parking-lot.md` — Deferred features and rationale
- `docs/SYSTEM-DESIGN.md` — Operational architecture reference
- `docs/plans/` — Implementation design documents

**ADR Resources:**
- [ADR GitHub org](https://adr.github.io/)
- Michael Nygard's blog post on ADRs
- [MADR](https://adr.github.io/madr/) (Markdown ADR format)

---

*This log is append-only. Update status fields as decisions evolve, but never delete historical context.*
