# 6.2 Failure Modes Analysis

**Purpose:** Document what breaks, how users notice, and recovery paths for all major subsystems.

**Date:** December 6, 2025
**Methodology:** Subsystem-by-subsystem analysis of failure scenarios
**Scope:** Production-ready components only (Phase 2c complete features)

---

## 1. Capture Processing Failures

### 1.1 AI Entity Extraction Unavailable

**Trigger:** `ANTHROPIC_API_KEY` not set OR Claude API down

**What Breaks:**
- Quick Capture entity extraction fails
- No entity suggestions
- No placement recommendations

**User Experience:**
- "Processing" spinner runs indefinitely
- OR: Shows fallback extraction (capitalized phrases only)
- No error message displayed

**Detection:**
```typescript
// QuickCapture.svelte lines 149-172
try {
  const result = await apiPost('/capture/process', { ... });
  processingResult = result;
} catch (err) {
  error = err.message || String(err);  // Generic error shown
}
```

**Recovery Path:**
1. Fallback extraction runs automatically (backend)
2. User sees basic entity list (capitalized phrases)
3. Can manually add entities
4. Can still save capture with manual classification

**Mitigation Status:** ✅ **IMPLEMENTED**
- Fallback extraction in `capture_service.py` lines 151-176
- Regex-based entity detection works without AI

**Remaining Risk:** Medium - Fallback is much lower quality than AI

---

### 1.2 Unclassifiable Captures

**Trigger:** Content too vague/abstract for entity extraction

**What Breaks:**
- Empty entity list
- No placement suggestions
- User stuck with raw text

**User Experience:**
- "No entities found" message (if implemented)
- Empty entity chips section
- Must manually route to folder

**Detection:**
```typescript
// QuickCapture.svelte
{#if processingResult?.extracted_entities.length === 0}
  <p class="no-entities">No entities found. Try being more specific.</p>
{/if}
```

**Recovery Path:**
1. User can manually type entity names
2. User can select idea type directly (7 seedling types)
3. User can save to `/Daily/` for later processing

**Mitigation Status:** ⚠️ **PARTIAL**
- Empty state handling exists
- Manual entity addition not yet implemented

**Remaining Risk:** Low - User can still process capture manually

---

### 1.3 Backend Unreachable During Capture

**Trigger:** Backend down OR network issue

**What Breaks:**
- Quick Capture API calls fail
- No processing
- Data stuck in browser

**User Experience:**
- "Failed to connect to backend" error
- Capture remains in UI but not saved
- No offline queue

**Detection:**
```typescript
// siyuan-structure.ts callBackendApi()
try {
  const response = await fetch(url, options);
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
} catch (error) {
  console.error('[API]', error);
  throw error;  // Propagates to caller
}
```

**Recovery Path:**
1. Error displayed to user
2. User can copy text before closing
3. Must retry when backend is back
4. **NO OFFLINE QUEUE** (data lost if not copied)

**Mitigation Status:** ❌ **MISSING**
- No localStorage fallback
- No offline queue
- No retry mechanism

**Remaining Risk:** **HIGH** - Data loss possible

**Recommended Fix:**
```typescript
// Add to QuickCapture.svelte
async function saveToLocalStorageQueue(capture: CaptureItem) {
  const queue = JSON.parse(localStorage.getItem('offline_queue') || '[]');
  queue.push({...capture, queued_at: Date.now()});
  localStorage.setItem('offline_queue', JSON.stringify(queue));
}

// On reconnect, drain queue
async function drainOfflineQueue() {
  const queue = JSON.parse(localStorage.getItem('offline_queue') || '[]');
  for (const item of queue) {
    await apiPost('/capture', item);
  }
  localStorage.removeItem('offline_queue');
}
```

---

## 2. Graph Data Corruption/Messiness

### 2.1 Duplicate Entity Names

**Trigger:** Books use different capitalizations ("Executive Function" vs "executive function")

**What Breaks:**
- Multiple nodes for same concept
- Relationship fragmentation
- Search returns duplicates

**User Experience:**
- Confusing search results
- "Why are there two Executive Function entries?"
- Graph navigation shows partial relationships

**Detection:**
```cypher
// Find duplicates
MATCH (e)
WHERE e.name IS NOT NULL
WITH toLower(e.name) AS name_lower, COLLECT(e) AS nodes
WHERE SIZE(nodes) > 1
RETURN name_lower, nodes
```

**Recovery Path:**
1. Manual merge in Neo4j
2. Redirect all relationships to canonical node
3. Delete duplicates

**Mitigation Status:** ⚠️ **PARTIAL**
- Deduplication exists in ingestion (`deduplicate_entities()`)
- But doesn't catch cross-book variations
- No merge UI

**Remaining Risk:** Medium - Accumulates over time

**Prevention:**
```python
# library/graph/entities.py - enhance dedup
def normalize_entity_name(name: str) -> str:
    """Normalize entity names for deduplication."""
    # Lowercase, remove articles, strip punctuation
    name = name.lower()
    name = re.sub(r'^(the|a|an)\s+', '', name)
    name = re.sub(r'[^\w\s-]', '', name)
    return name.strip()
```

---

### 2.2 Orphaned Nodes

**Trigger:** Book deleted OR entity extracted but never linked

**What Breaks:**
- Nodes with no relationships
- Clutter graph
- Waste storage

**User Experience:**
- Search finds entities with "No relationships"
- Flow mode shows dead ends
- Confusing exploration

**Detection:**
```cypher
// Find orphans
MATCH (e)
WHERE NOT (e)--()
RETURN e.name, labels(e)
```

**Recovery Path:**
1. Periodic cleanup job
2. Delete nodes with no relationships AND no recent visits

**Mitigation Status:** ❌ **MISSING**
- No cleanup job
- Orphans accumulate

**Remaining Risk:** Low - Doesn't break functionality, just messy

**Recommended Fix:**
```python
# scripts/cleanup_graph.py
async def remove_orphaned_entities(kg: KnowledgeGraph, min_age_days: int = 30):
    """Remove entities with no relationships and no recent activity."""
    query = """
    MATCH (e)
    WHERE NOT (e)--()
      AND e.created_at < datetime() - duration({days: $min_age_days})
      AND (e.last_visited IS NULL OR e.last_visited < datetime() - duration({days: $min_age_days}))
    DELETE e
    RETURN COUNT(e) AS deleted_count
    """
    result = kg.execute_query(query, min_age_days=min_age_days)
    return result['deleted_count']
```

---

### 2.3 Invalid Relationship Types

**Trigger:** LLM generates relationship type with special characters OR spaces

**What Breaks:**
- Neo4j Cypher syntax errors
- Relationship creation fails
- Backend 500 errors

**User Experience:**
- "Failed to create relationship" error
- Concept formalization wizard fails at Relate step
- Confusing error message

**Detection:**
```python
# Current: library/graph/neo4j_client.py add_relationship()
# Sanitizes relationship types (✅ ALREADY IMPLEMENTED)
relationship_type = re.sub(r'[^A-Z0-9_]', '', relationship_type.upper())
if not relationship_type:
    relationship_type = "RELATED_TO"
```

**Recovery Path:**
1. Automatic sanitization converts invalid types
2. Falls back to "RELATED_TO"
3. No user intervention needed

**Mitigation Status:** ✅ **IMPLEMENTED**
- Sanitization in neo4j_client.py
- Fallback to RELATED_TO

**Remaining Risk:** Very Low - Handled gracefully

---

## 3. Dialogue Session Stuck/Loops

### 3.1 AI Response Fails to Generate

**Trigger:** OpenAI API timeout OR rate limit hit

**What Breaks:**
- ForgeMode stuck in "Generating response..." state
- User message sent but no AI reply
- Session hangs

**User Experience:**
- Spinner runs indefinitely
- No error message
- Cannot send another message

**Detection:**
```typescript
// ForgeMode.svelte lines 250-280 (handleSend)
try {
  const response = await apiPost('/session/message', {
    session_id: activeSessionId,
    message: userMessage
  });
  // ... handle response
} catch (error) {
  // ❌ ERROR NOT HANDLED - UI stays in loading state
}
```

**Recovery Path:**
1. **CURRENTLY BROKEN** - No recovery without page reload
2. User must refresh plugin
3. Session data lost if not saved

**Mitigation Status:** ❌ **CRITICAL MISSING**
- No error handling in ForgeMode message sending
- No timeout
- No retry

**Remaining Risk:** **HIGH** - Complete UI lockup

**Recommended Fix:**
```typescript
// ForgeMode.svelte
async function handleSend() {
  isWaitingForResponse = true;
  error = null;

  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

    const response = await apiPost('/session/message', {
      session_id: activeSessionId,
      message: userMessage
    }, { signal: controller.signal });

    clearTimeout(timeoutId);
    // ... process response
  } catch (error) {
    if (error.name === 'AbortError') {
      error = "Response timed out. Please try again.";
    } else {
      error = error.message || "Failed to send message";
    }
  } finally {
    isWaitingForResponse = false;  // Always unlock UI
  }
}
```

---

### 3.2 State Detection Misidentifies User State

**Trigger:** User switches topics mid-session

**What Breaks:**
- Questions don't match current discussion
- Wrong inquiry approach selected
- Confusing/irrelevant questions

**User Experience:**
- "Why is it asking about X when I'm talking about Y?"
- Questions feel random
- Breaks thinking partnership immersion

**Detection:**
- No automatic detection
- User must manually report

**Recovery Path:**
1. User can ignore irrelevant questions
2. User can switch modes manually
3. Next question should recalibrate (if state detection works)

**Mitigation Status:** ⚠️ **PARTIAL**
- State detection exists (`StateDetectionService`)
- Looks at last 3 messages
- **BUT**: No topic shift detection

**Remaining Risk:** Medium - Degrades experience but doesn't break system

**Prevention:**
```python
# state_detection_service.py enhancement
def detect_topic_shift(messages: list[Message]) -> bool:
    """Detect if topic changed between messages."""
    if len(messages) < 4:
        return False

    # Extract entities from last 3 vs previous 3
    recent_entities = extract_entities(messages[-3:])
    previous_entities = extract_entities(messages[-6:-3])

    # Calculate Jaccard similarity
    similarity = len(recent_entities & previous_entities) / len(recent_entities | previous_entities)

    return similarity < 0.3  # Topic shifted if < 30% overlap
```

---

## 4. Flow Mode Overwhelms User

### 4.1 Too Many Relationships Displayed

**Trigger:** Entity with 50+ relationships (e.g., "Executive Function")

**What Breaks:**
- Flow panel filled with relationship cards
- Scrolling becomes tedious
- Can't find specific relationship

**User Experience:**
- "Information overload"
- Scrolls for 30 seconds to see all
- Misses important connections

**Detection:**
- User reports "too many"
- Analytics show high bounce rate on popular entities

**Recovery Path:**
1. Group by relationship type (✅ ALREADY IMPLEMENTED)
2. Collapse groups by default
3. "Show more" pagination

**Mitigation Status:** ⚠️ **PARTIAL**
- Grouping exists (`RELATIONSHIP_TYPE_LABELS`)
- But all groups expanded by default
- No pagination

**Remaining Risk:** Medium - Degrades UX for popular entities

**Recommended Fix:**
```svelte
<!-- FlowMode.svelte -->
{#each Object.entries(groupedRelationships) as [type, rels]}
  <div class="relationship-group">
    <button on:click={() => toggleGroup(type)} class="group-header">
      <span>{RELATIONSHIP_TYPE_LABELS[type]} ({rels.length})</span>
      <span class="chevron">{expandedGroups.has(type) ? '▼' : '▶'}</span>
    </button>

    {#if expandedGroups.has(type)}
      <div class="group-relationships">
        {#each rels.slice(0, showAllGroups.has(type) ? undefined : 5) as rel}
          <!-- relationship card -->
        {/each}
        {#if rels.length > 5 && !showAllGroups.has(type)}
          <button on:click={() => showAll(type)}>Show all {rels.length} →</button>
        {/if}
      </div>
    {/if}
  </div>
{/each}
```

---

### 4.2 Journey Path Too Long

**Trigger:** User explores 50+ entities in one session

**What Breaks:**
- `explorationPath` array grows unbounded
- Memory usage increases
- Breadcrumb display overflows

**User Experience:**
- Slight performance degradation
- Breadcrumb trail truncated
- Can't see full journey

**Detection:**
```typescript
// FlowMode.svelte - check explorationPath.length
if (explorationPath.length > 100) {
  console.warn('Exploration path very long:', explorationPath.length);
}
```

**Recovery Path:**
1. Truncate path at backend (save last 100 only)
2. Keep full path in Neo4j Journey node
3. UI shows last 20 with "..." for older

**Mitigation Status:** ❌ **MISSING**
- No limit on explorationPath
- No truncation
- localStorage quota could be exceeded

**Remaining Risk:** Low - Rare for users to explore 100+ entities

**Recommended Fix:**
```typescript
// FlowMode.svelte
const MAX_PATH_LENGTH = 100;

function addToPath(entityId: string) {
  explorationPath = [...explorationPath, entityId];
  if (explorationPath.length > MAX_PATH_LENGTH) {
    explorationPath = explorationPath.slice(-MAX_PATH_LENGTH);  // Keep last 100
  }
}
```

---

## 5. Question Engine Generates Irrelevant Questions

### 5.1 Context Mismatch

**Trigger:** Question generated from stale context OR wrong mode

**What Breaks:**
- Question doesn't match current topic
- Asks about entity not in discussion
- Confuses user

**User Experience:**
- "This question doesn't make sense here"
- Ignores question
- Loses trust in thinking partnership

**Detection:**
- User doesn't respond to question
- User skips many questions in a row

**Recovery Path:**
1. User skips question (❌ NO SKIP BUTTON)
2. User answers vaguely
3. System generates new question

**Mitigation Status:** ⚠️ **PARTIAL**
- Questions tied to current entity/topic
- But no skip mechanism
- No feedback loop

**Remaining Risk:** Medium - Degrades UX but doesn't break flow

**Recommended Fix:**
```tsx
// QuestionsSection.tsx (Readest) or ForgeMode.svelte (SiYuan)
<div class="question-actions">
  <button on:click={() => skipQuestion(question.id)}>Skip</button>
  <button on:click={() => respondToQuestion(question.id, response)}>Respond</button>
</div>

// Track skips for analytics
async function skipQuestion(questionId: string) {
  await apiPost('/question-engine/feedback', {
    question_id: questionId,
    action: 'skipped',
    reason: 'not_relevant'
  });
  // Remove from UI or mark as skipped
}
```

---

### 5.2 Question Class Mismatch for Mode

**Trigger:** Mode→Approach→Class mapping error

**What Breaks:**
- Learning mode gets Meta-Cognitive questions (wrong)
- Reflecting mode gets Schema-Probe questions (wrong)

**User Experience:**
- Questions feel "off"
- Not aligned with mode purpose

**Detection:**
```python
# Verify mapping
expected_classes = {
  'learning': ['schema_probe', 'causal', 'anchor'],
  'articulating': ['anchor', 'meta_cognitive'],
  ...
}

if question.class not in expected_classes[mode]:
  logger.warning(f"Question class {question.class} unexpected for mode {mode}")
```

**Recovery Path:**
1. Backend logs warning
2. Question still delivered (degraded experience)
3. Next question should correct

**Mitigation Status:** ✅ **IMPLEMENTED**
- APPROACH_TO_CLASSES mapping validated
- MODE→APPROACH mapping correct

**Remaining Risk:** Very Low - Mapping is well-tested

---

## 6. Mode Transition at Wrong Time

### 6.1 Manual Mode Switch Mid-Session

**Trigger:** User changes mode in ForgeMode selector

**What Breaks:**
- Session template changes mid-stream
- Progress lost if template-based
- Conversation context mismatch

**User Experience:**
- "I was in the middle of something!"
- Confusion about what changed
- Lost section responses

**Detection:**
- User tries to switch mode while session active

**Recovery Path:**
1. **CURRENT:** No prevention - mode switches immediately
2. **IDEAL:** Warn before switching
3. Option to save current session first

**Mitigation Status:** ❌ **MISSING**
- No warning on mode switch
- Session data not preserved

**Remaining Risk:** Medium - Annoying but recoverable

**Recommended Fix:**
```svelte
<!-- ForgeMode.svelte mode selector -->
async function handleModeChange(newMode: string) {
  if (activeSessionId && currentMode !== newMode) {
    const confirmed = confirm(
      `Switching modes will end the current ${currentMode} session. Continue?`
    );

    if (!confirmed) {
      selectedMode = currentMode;  // Revert selector
      return;
    }

    // Save current session before switching
    await handleEndSession();
  }

  currentMode = newMode;
  // Start new session with new mode
}
```

---

## 7. SiYuan Plugin Crash/Reload

### 7.1 Plugin Unhandled Exception

**Trigger:** JavaScript error in any component

**What Breaks:**
- Entire plugin UI disappears
- User loses context
- Must reload SiYuan

**User Experience:**
- Plugin icon grays out
- OR: Blank panel
- "Something went wrong" (if error boundary exists)

**Detection:**
```typescript
// Check for Svelte error boundaries (❌ NOT IMPLEMENTED)
// Error propagates to browser console only
```

**Recovery Path:**
1. User reloads SiYuan (Ctrl+R or restart)
2. Plugin reinitializes
3. Session data lost if not saved to backend

**Mitigation Status:** ❌ **CRITICAL MISSING**
- No error boundaries
- No crash recovery
- No error reporting

**Remaining Risk:** **HIGH** - Complete plugin failure

**Recommended Fix:**
```svelte
<!-- Plugin root component -->
<script>
  import { onError } from 'svelte';

  let error: Error | null = null;
  let errorInfo: string | null = null;

  onError((e) => {
    error = e.error;
    errorInfo = e.message;
    console.error('[Plugin Error]', e);

    // Optional: Report to backend
    apiPost('/errors/report', {
      error: e.error.toString(),
      stack: e.error.stack,
      component: e.filename
    }).catch(() => {});
  });
</script>

{#if error}
  <div class="error-boundary">
    <h3>Something went wrong</h3>
    <p>{errorInfo}</p>
    <button on:click={() => location.reload()}>Reload Plugin</button>
  </div>
{:else}
  <!-- Normal plugin UI -->
{/if}
```

---

### 7.2 SiYuan API Unavailable

**Trigger:** SiYuan desktop app not running OR API disabled

**What Breaks:**
- Cannot create notebooks/documents
- Cannot query blocks
- Plugin functions but can't persist

**User Experience:**
- "Failed to save to SiYuan" errors
- Data stuck in plugin state
- No offline fallback

**Detection:**
```typescript
// siyuan-structure.ts - API calls
async function apiRequest(endpoint: string, data: any) {
  try {
    const response = await fetch(`/api${endpoint}`, {
      method: 'POST',
      body: JSON.stringify(data)
    });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return await response.json();
  } catch (error) {
    console.error('[SiYuan API]', error);
    throw error;
  }
}
```

**Recovery Path:**
1. Error displayed to user
2. **NO RETRY** - operation fails
3. Must manually retry

**Mitigation Status:** ⚠️ **PARTIAL**
- Errors logged and thrown
- But no automatic retry
- No queue for failed operations

**Remaining Risk:** Medium - Data loss possible

---

## 8. Readest Entity Overlay Performance

### 8.1 Regex Catastrophic Backtracking (FIXED)

**Trigger:** Book with 500+ entities

**Status:** ✅ **FIXED** - BUG-R02 resolved Dec 5
- Trie-based matcher implemented
- Linear O(n) performance

**Previous Failure Mode (for reference):**
- Regex pattern with 500 alternations caused exponential backtracking
- Browser froze for 5-10 seconds
- UI completely unresponsive

**Current Mitigation:** ✅ **COMPLETE**
- `entity.ts` now uses trie-based matching
- Performance tested with 500+ entities
- No freeze observed

---

### 8.2 Entity Fetch Timeout

**Trigger:** Slow network OR backend overloaded

**What Breaks:**
- Entity overlay never populates
- Highlights exist but no data
- Click on entity does nothing

**User Experience:**
- Book looks normal (no highlights)
- OR: Highlights visible but not clickable
- Confusing state

**Detection:**
```typescript
// flowModeStore.ts fetchEntitiesForBook()
// ✅ AbortController implemented (BUG-R03 fixed)
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 10000);

try {
  const response = await fetch(url, { signal: controller.signal });
  // ...
} catch (error) {
  if (error.name === 'AbortError') {
    console.warn('Entity fetch timed out');
  }
} finally {
  clearTimeout(timeoutId);
}
```

**Recovery Path:**
1. Automatic retry (not implemented)
2. User must reload book
3. Backend caches entities for next load

**Mitigation Status:** ⚠️ **PARTIAL**
- Timeout exists (10s)
- AbortController prevents memory leak
- But no retry logic

**Remaining Risk:** Low - User can reload

---

## 9. Neo4j/Qdrant Unavailable

### 9.1 Neo4j Connection Lost

**Trigger:** Neo4j container stops OR network issue

**What Breaks:**
- ALL graph operations fail
- Entity search breaks
- Concept formalization fails
- Capture processing fails

**User Experience:**
- Every operation shows "Database error"
- Complete system failure
- Must restart Neo4j

**Detection:**
```python
# library/graph/neo4j_client.py
try:
  with self.driver.session() as session:
    result = session.run(query, **params)
except Exception as e:
  logger.error(f"Neo4j error: {e}")
  raise DatabaseConnectionError(f"Failed to connect to Neo4j: {e}")
```

**Recovery Path:**
1. Check Neo4j container: `docker compose ps`
2. Restart if needed: `docker compose restart neo4j`
3. Backend auto-reconnects on next query
4. **NO OFFLINE QUEUE** - operations fail

**Mitigation Status:** ⚠️ **PARTIAL**
- Error handling exists
- But no connection pooling retry
- No circuit breaker pattern

**Remaining Risk:** **HIGH** - Complete system outage

**Recommended Fix:**
```python
# neo4j_client.py
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=1, max=10))
def execute_query(self, query: str, **params):
    """Execute query with automatic retry on connection failure."""
    try:
        with self.driver.session() as session:
            result = session.run(query, **params)
            return [record.data() for record in result]
    except Exception as e:
        logger.warning(f"Query failed, will retry: {e}")
        raise
```

---

### 9.2 Qdrant Unavailable

**Trigger:** Qdrant container stops

**What Breaks:**
- Semantic search fails
- Vector-based entity matching breaks
- Similarity queries fail

**User Experience:**
- Search returns no results
- OR: Fallback to keyword search (if implemented)
- Degraded search quality

**Detection:**
```python
# Check if used in current implementation
# ❌ Qdrant NOT YET INTEGRATED - no impact
```

**Current Status:** No impact - Qdrant not yet actively used

**Future Risk:** Low - Can fallback to Neo4j full-text search

---

## Summary: Critical Failure Modes

| Subsystem | Failure | Detection | Mitigation | Risk | Priority |
|-----------|---------|-----------|------------|------|----------|
| **Capture** | Backend unreachable | Error thrown | ❌ None | **HIGH** | P1 |
| **Capture** | AI extraction fails | Fallback runs | ✅ Regex fallback | Medium | P2 |
| **Dialogue** | AI timeout | No error | ❌ None | **HIGH** | P1 |
| **Dialogue** | State misidentification | User reports | ⚠️ Partial | Medium | P3 |
| **Flow** | Too many relationships | User scrolls | ⚠️ Grouping | Medium | P2 |
| **Flow** | Journey too long | Memory grows | ❌ None | Low | P3 |
| **Questions** | Irrelevant questions | User skips | ❌ No skip UI | Medium | P2 |
| **Plugin** | JavaScript exception | Plugin crashes | ❌ No error boundary | **HIGH** | P1 |
| **SiYuan** | API unavailable | Error thrown | ⚠️ Logged only | Medium | P2 |
| **Readest** | Entity fetch timeout | 10s timeout | ✅ AbortController | Low | P3 |
| **Backend** | Neo4j down | Connection error | ⚠️ Error only | **HIGH** | P1 |
| **Backend** | Qdrant down | N/A | N/A (unused) | None | P4 |
| **Graph** | Duplicate entities | User reports | ⚠️ Dedup partial | Medium | P2 |
| **Graph** | Orphaned nodes | Accumulates | ❌ No cleanup | Low | P3 |

---

## Recommendations

### Immediate (P1)
1. Add error boundary to SiYuan plugin root
2. Add timeout + error handling to ForgeMode AI responses
3. Add offline queue for captures (localStorage fallback)
4. Implement connection retry for Neo4j operations

### Short-term (P2)
1. Add "Skip question" button to Q&A interfaces
2. Implement relationship pagination (collapse by default, show 5 per group)
3. Add mode switch warning in ForgeMode
4. Enhance duplicate entity detection (normalize names)

### Long-term (P3)
1. Build graph cleanup job for orphaned nodes
2. Add topic shift detection to state detection
3. Implement journey path truncation (keep last 100)
4. Add analytics for question relevance

---

## References

**Source Code:**
- `.worktrees/siyuan/ies/plugin/src/views/` (UI components)
- `.worktrees/readest/readest/apps/readest-app/src/` (Readest components)
- `ies/backend/src/ies_backend/services/` (Backend services)
- `library/graph/` (Graph clients)

**Bug Reports:**
- `docs/CRITICAL-ANALYSIS-2025-12-05.md` (SiYuan bugs)
- `docs/ANALYSIS-READEST-2025-12-05.md` (Readest bugs, many fixed)

**Next:** See `6.3-Works-For-Chris-Checklist.md` for ADHD-specific validation.
